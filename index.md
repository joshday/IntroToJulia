# Table of Contents

- [Intro](#intro)
    - [Resources](#resources)
    - [Sapir-Worf Hypothesis](#sapir-worf-hypothesis)
    - [Why do we need another language?](#why-do-we-need-another-language)
    - [What is Julia?](#what-is-julia)
    - [Benchmarks, Time Relative to C](#benchmarks,-time-relative-to-c)
    - [Julia's Growth](#julia's-growth)
- [Basics](#basics)
    - [Using Packages](#using-packages)
    - [How do I do X in Julia?](#how-do-i-do-x-in-julia)
    - [How should I write code?](#how-should-i-write-code)
    - [Reading and Writing](#reading-and-writing)
    - [Linear Algebra](#linear-algebra)
    - [Macros (functions of expressions)](#macros-(functions-of-expressions))
- [Type System](#type-system)
- [Multiple Dispatch](#multiple-dispatch)
- [Plotting](#plotting)
- [Using R or Python with Julia](#using-r-or-python-with-julia)
- [Gotchas](#gotchas)


---

![](https://github.com/JuliaGraphics/julia-logo-graphics/blob/master/images/julia-logo-325-by-225.png?raw=true)


### Introduction to Julia

\n\n\n\n\n\n\n

#### Dr. Josh Day

  * GitHub: `@joshday`
  * Email: emailjoshday@gmail.com

# Intro

## Resources

  * [https://julialang.org](https://julialang.org)
  * [https://juliaobserver.com/](https://juliaobserver.com/) (finding packages)
  * [https://discourse.julialang.org](https://discourse.julialang.org) (ask for help)
  * [http://julialang.slack.com/](http://julialang.slack.com/) (ask for help)
  * [https://docs.julialang.org/en/](https://docs.julialang.org/en/) (documentation)

## Sapir-Worf Hypothesis

  * **Your language influences how you think.**
  * In programming, your language influences how you solve problems.

## Why do we need another language?

  * R is great for statistics
  * Matlab is great for computational linear algebra
  * Python is great for a little bit of everything

### However...

  * All three have slow for-loops
  * The best R/Python libraries are written in C/Fortran
  * Matlab is closed source
  * R is down to 6 people with commit access to base R
  * They were designed without modern technologies which are now being shoehorned in

**How do these languages influence how you solve problems when for loops are "bad"?**

### Wouldn't it be great if we had a language which...

  * Was open source
  * Had an active community (743 contributors to base Julia as of Sep 25, 2018)
  * Was fast (avoids two language problem)
  * Had clear syntax (Easy to read and write)

## What is Julia?

> Julia is a high-level, high-performance dynamic programming language for technical computing, with syntax that is familiar to users of other technical computing environments


### Aims to solve the "two language problem"

  * Prototype code goes into high-level language like Python, production code goes into low-level language like C++

### Write high-level, abstract code that closely resembles mathematical formulas

  * Yet produces fast, low-level machine code that has traditionally only been generated by static languages.

### Julia is more than just "Fast R" or "Fast Matlab"

  * Performance comes from features that work well together.
  * You can't just take the magic dust that makes Julia fast and sprinkle it on [language of choice]

### Julia Features

  * Type system
  * Multiple dispatch
  * Type Inference
  * Metaprogramming (macros)
  * Just-in-time (JIT) compilation using LLVM
  * Clean, familiar syntax
  * Most of Julia is written in Julia!

### Multiple Dispatch

  * Multiple dispatch is the idea that a function calls a different *method* depending on the types of the arguments (more on this later).

      * Note: Type annotations will **not** affect performance!

```julia
julia> f(x::Int) = 1
f (generic function with 1 method)

julia> f(x::Float64) = 2
f (generic function with 2 methods)

julia> f(0)
1

julia> f(0.0)
2
```

Julia packages are typically based around a grammar or interface of how to talk about some thing. 

Consider the [Distributions.jl](https://github.com/JuliaStats/Distributions.jl) package.  What is the grammar of how one talks about a probability distribution?

```julia
julia> using Distributions


julia> d1 = Normal(0.0, 1.0)
Distributions.Normal{Float64}(0.0, 1.0)

julia> d2 = Beta(3.0, 5.0)
Distributions.Beta{Float64}(3.0, 5.0)

julia> mean(d1)
0.0

julia> mean(d2)
0.375

julia> cdf(d1, 1)
0.841344746068543

julia> cdf(d2, 1)
1.0
```

## Benchmarks, Time Relative to C

![](https://julialang.org/images/benchmarks.svg)

## Julia's Growth

  * [https://pkg.julialang.org/pulse.html](https://pkg.julialang.org/pulse.html)
  * [http://www.timqian.com/star-history/#julialang/julia](http://www.timqian.com/star-history/#julialang/julia)

![](https://pkg.julialang.org/img/allver.svg)

![](https://pkg.julialang.org/img/stars.svg)

# Basics

### The REPL

Your first experience with Julia will probably be via the REPL (read-eval-print-loop)

```julia
julia> x = 1
1

julia> y = 2
2
```

There are several **REPL Modes** that can be activated by certain characters:

  * `?` (help)
  * `]` (package manager)
  * `;` (shell)
  * `$` (R via [RCall.jl](https://github.com/JuliaInterop/RCall.jl))

### Things have types

```julia
julia> typeof(1)
Int64

julia> typeof(1.0)
Float64

julia> typeof([1, 2])
Array{Int64,1}
```

### You can use unicode characters

Try typing `\alpha` or `\:+1:` and hit tab.

```julia
julia> ðŸ‘ = "thumbs up!"
"thumbs up!"
```

### Code blocks use `end`

```julia
function f(x)
    x + 1
end
```

```julia
for i in 1:5
    println(i)
end
```

## Using Packages

```julia
julia> using Distributions


julia> g = Gamma(5, 1)
Distributions.Gamma{Float64}(5.0, 1.0)

julia> rand(g, 3)
3-element Array{Float64,1}:
 7.0170186620623465
 1.7862934172975231
 7.133388266994161

julia> mean(g), var(g), mode(g), pdf(g, 5)
(5.0, 5.0, 4.0, 0.17546736976785068)
```

### Packages are modules

```julia
julia> module Thing
myfun(x) = "hello"
end;


julia> Thing.myfun(1)
"hello"
```

  * To add a registered package, you can do:

```julia
using Pkg
Pkg.add("CoolPackage")
```

```julia
using Pkg
pkg"add CoolPackage"
```

or use the package manager REPL mode: `] add Package`.

Side note: characters before a string are a *string macro* which can treat the string in different ways.  In this case, `pkg"some command"` runs `some command` in Julia's package manager.

  * To load a package:

      * `using CoolPackage`

          * Load exported names, e.g. `exported_function`
          * Unexported names accessed via `CoolPackage.thing`
      * `import CoolPackage`

          * Everything accessed via `CoolPackage.exported_function`

## How do I do X in Julia?

1. `?X` (search the help)
2. Official docs (search the docs)
3. Discourse/Slack (ask question on slack or discourse)
4. Google as last resort

Historically Google has been particularly bad at finding Julia docs (top hits are for old versions).

## How should I write code?

  * Jupyter

      * For reproducibility (see also [Weave.jl](https://github.com/mpastell/Weave.jl) and [Literate.jl](https://github.com/fredrikekre/Literate.jl)), sharing code with others, and working with data on a server.
      * **NOT** your main work environment
  * Atom and VS Code have good Julia plug-ins (I use VS Code)
  * Julia Pro (Atom with the Juno plug-in preinstalled)

## Reading and Writing

  * Delimited Files

```julia
julia> using DelimitedFiles


julia> x = randn(10)
10-element Array{Float64,1}:
 -1.2958387990908027 
 -1.5655117414120094 
  1.1145923024859985 
  0.41461550854590656
  1.134506130364492  
  2.812648429643799  
  0.7080843144220199 
  1.1714029391085563 
  1.3816489451786416 
 -1.0669220758912008

julia> writedlm("temp.csv", x, ',')


julia> y = readdlm("temp.csv")
10Ã—1 Array{Float64,2}:
 -1.2958387990908027 
 -1.5655117414120094 
  1.1145923024859985 
  0.41461550854590656
  1.134506130364492  
  2.812648429643799  
  0.7080843144220199 
  1.1714029391085563 
  1.3816489451786416 
 -1.0669220758912008
```

  * (De)serialization

```julia
julia> using Serialization


julia> x = randn(10)
10-element Array{Float64,1}:
  0.8624502665810877 
  1.2468877669287635 
  0.19889916888748227
 -0.890238447106665  
 -0.09045863274691845
  0.3702299901212688 
  0.8538579795217942 
 -0.30774552803566674
  0.26232923731795255
 -1.0531398294964769

julia> open(touch("temp"), "w") do io
    serialize(io, x)
end
80

julia> y = open(deserialize, "temp", "r")
10-element Array{Float64,1}:
  0.8624502665810877 
  1.2468877669287635 
  0.19889916888748227
 -0.890238447106665  
 -0.09045863274691845
  0.3702299901212688 
  0.8538579795217942 
 -0.30774552803566674
  0.26232923731795255
 -1.0531398294964769
```

## Linear Algebra

  * 1-based indexing

```julia
julia> x = rand(3, 3)
3Ã—3 Array{Float64,2}:
 0.198128  0.961601  0.619053
 0.364257  0.796788  0.408096
 0.175839  0.475348  0.418318

julia> x[1]
0.19812763329698613

julia> x[end-1]
0.4080960544913004

julia> x * rand(3)
3-element Array{Float64,1}:
 1.2517520753960785
 1.0099938669285933
 0.7268095853530321

julia> rand(2, 2, 2)  # high-dimensional arrays
2Ã—2Ã—2 Array{Float64,3}:
[:, :, 1] =
 0.240916  0.160725
 0.86885   0.638998

[:, :, 2] =
 0.708654  0.84775  
 0.471945  0.0447675
```

## Macros (functions of expressions)

Why does this need to be a macro?

```julia
julia> @show x = 1
1
```

  * **Super useful macros**

      * `@time` (time and allocations)
      * `@edit` (open up source code)
      * `@which` (find the method being called)
      * `@benchmark` (from [BenchmarkTools.jl](https://github.com/JuliaCI/BenchmarkTools.jl))

```julia
julia> @time for i in 1:10
    sleep(.1)
end
```

# Type System

  * **When thinking about types in Julia, think about sets.**
  * Explore the type hierarchy with `supertype`, `subtypes`, `typeof`, `<:`

```julia
julia> typeof(1)
Int64

julia> supertype(Int)
Signed

julia> subtypes(Number)
2-element Array{Any,1}:
 Complex
 Real

julia> Int <: Number
true
```

# Multiple Dispatch

Here is a very naive implementation of a quantile finder based on Newton's method.  

```julia
using Distributions

function myquantile(d, q)
    out = mean(d)
    for i in 1:10
        out -= (cdf(d, out) - q) / pdf(d, out)
    end
    out
end
```

I have not told Julia anything about what `d` or `q` is, but when I provide arguments such  as `Distributions.Normal(0, 1)` and `0.5`, Julia will compile specialized code.

```julia
julia> myquantile(Normal(0, 1), .5)
0.0

julia> myquantile(Gamma(5, 1), .7)
5.890361313697006

julia> myquantile(Beta(2, 4), .1)
0.11223495854585855
```

**How would you do this in R?** You would need to rewrite this function for every distribution!  

# Plotting

  * No built in plotting package
  * [Plots.jl](https://github.com/JuliaPlots/Plots.jl)

      * Interface around multiple plotting "backends"
  * [Makie.jl](https://github.com/JuliaPlots/Makie.jl)

```julia
julia> using Plots


julia> p = plot(randn(20, 2), seriestype = [:line :scatter]);


julia> png(p, "build/myplot.png")
```

![](myplot.png)

# Using R or Python with Julia

  * [RCall.jl](https://github.com/JuliaInterop/RCall.jl)
  * [PyCall.jl](https://github.com/JuliaPy/PyCall.jl)

**Demo in Jupyter Notebook**

# Gotchas

  * Avoid global scope

