![](https://a248.e.akamai.net/secure.meetupstatic.com/photos/event/7/c/8/0/highres_328291872.jpeg)


```julia;hide;
using Pkg
pkg"add Plots"
pkg"add Distributions"
pkg"add OnlineStats"
using InteractiveUtils
```

# Introduction to Julia

## Josh Day

- GitHub: `@joshday`
- Email: emailjoshday@gmail.com

---

# Sapir-Worf Hypothesis
- **Your language influences how you think.**
- In programming, your language influences how you solve problems.

---

# Why do we need another language?

- R is great for statistics
- Matlab is great for computational linear algebra
- Python is great for a little bit of everything

### However...
- All three have slow for-loops
- The best R/Python libraries are written in C/Fortran
- Matlab is closed source
- R is down to 6 people with commit access to base R
- They were designed without modern technologies which are now being shoehorned in

**How do these languages influence how you solve problems when for loops are "bad"?**

### Wouldn't it be great if we had a language which...
- Was open source
- Had an active community (621 contributors to base Julia)
- Was fast (avoids two language problem)
- Had clear syntax (Easy to read and write)

---

# What is Julia?
> Julia is a high-level, high-performance dynamic programming language for technical computing, with syntax that is familiar to users of other technical computing environments

### Aims to solve the "two language problem"
- Prototype code goes into high-level language like Python, production code goes into low-level language like C++

### Write high-level, abstract code that closely resembles mathematical formulas
- yet produces fast, low-level machine code that has traditionally only been generated by static languages.

### Julia is more than just "Fast R" or "Fast Matlab"
- Performance comes from features that work well together.  
- You can't just take the magic dust that makes Julia fast and sprinkle it on [language of choice]

---

# Julia Features

- Type system
- Multiple dispatch
- Type Inference
- Metaprogramming (macros)
- Just-in-time (JIT) compilation using LLVM
- Clean, familiar syntax

---

# Benchmarks, Time Relative to C

![](https://julialang.org/images/benchmarks.svg)

---

# Julia's Growth

- http://pkg.julialang.org/pulse.html

![](http://pkg.julialang.org/img/allver.svg)

![](http://pkg.julialang.org/img/stars.svg)


---

# Basics

### The REPL

Your first experience with Julia will probably be via the REPL (read-eval-print-loop)

```julia; repl;
x = 1

y = 2
```

There are several **REPL Modes** that can be activated by certain characters:

- `?` (help)
- `]` (package manager)
- `;` (shell)
- `$` (R via [RCall.jl](https://github.com/JuliaInterop/RCall.jl))

### Things have types

```julia
typeof(1)       # Int
typeof(1.0)     # Float64
typeof([1, 2])  # Vector{Int}
```

### Code blocks use `end`

```julia
function f(x)
    x + 1
end
```

```julia
for i in 1:5
    println(i)
end
```

### Julia does many optimizations for you

```julia; repl;
f(x) = x ^ 2
@code_llvm f(1)
@code_llvm f(1.0)
```

### Using Packages

```julia
using Distributions
g = Gamma(5, 1)
rand(g, 3)
```